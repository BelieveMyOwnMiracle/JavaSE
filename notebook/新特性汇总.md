# Jdk8之后版本的新特性汇总

### (Java 10) 局部变量类型推断

Java 10 引入了 `var` 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。

在Java10之后，我们可以使用`var`关键字来根据后面的结果自动识别类型：

```java
var a = 10;
```

此时，无论我们修改后面的变量值为什么类型的值，都可以自动进行推断：



### (Java 14) Switch表达式

在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在我们要给不同分数的学生打等级（学生满分10分）我们之前学习的传统`switch`语句像这样写：

```java
int score = 9;
char grade;
switch (score) {
    case 10:
    case 9:
        grade = 'A';
        break;
    case 8:
        grade = 'B';
        break;
    case 7:
    case 6:
        grade = 'C';
        break;
    default:
        grade = 'D';
}
System.out.println("学生等级为: " + grade);
```

这是在是太累了，每一种情况都要单独编写`case`和`break`语句，从现在开始，我们可以使用新的`switch`语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：

```java
int score = 9;
//直接让grade接受switch的结果
char grade = switch (score) {
    case 10, 9 -> 'A';   //case后面直接使用->来指定返回结果
    case 8 -> 'B';
    case 6, 7 -> 'C';  //当存在多个匹配条件时，使用逗号分隔
    default -> 'D';
};  //别忘了这种写法相当于赋值，最后需要加分号
System.out.println("学生等级为: " + grade);
```

是不是看起来简单多了？其中`grade`得到的就是每一个`case`语句`->`符号后的结果，不需要任何`break`操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：

```java
var res = switch (obj) {   //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收
    case [匹配值, ...] -> "优秀";   //case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -> 来返回如果匹配此case语句的结果
    case ...   //根据不同的分支，可以存在多个case
    default -> "不及格";   //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的
};
```

不过，有些时候可能我们并不能直接指定返回的结果，比如存在前置操作的情况下，我们可以像这样编写：

```java
char grade = switch (score) {
    case 9 -> 'A';
    case 8 -> 'B';
    case 6, 7 -> {
        System.out.println("我是额外操作");   //存在前置操作，无法直接指定结果
        yield 'C';   //在最后使用yield关键字来指定结果
    }
    default -> 'D';
};
```

我们可以使用`yield`关键字来指定延迟返回的结果，同样的，不需要任何`break`操作，分支会自动结束（注意`yield`执行之后，后续不能再有任何代码了，因为已经结束了）

这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。但是注意，箭头语法和传统语法在Java 21之前是不允许混用的，Java 21之后可以相互混用。



### (Java 9) 交互式编程

如果各位小伙伴学习过其他语言，比如Python、JavaScript这类解释型语言，应该能够体验到命令行交互编程的快捷。而Java9同样推出了相似的功能，让我们能够在命令行中直接编写和运行Java代码，我们可以使用`jshell`命令打开交互式编程工具：

当不需要使用时，输入`/exit`指令即可退出：

![image-20250707202517718](https://s2.loli.net/2025/07/07/aWF92KYwqhPDgcz.png)



### (Java 16) 类型判断模式匹配

在Java 14，`instanceof`迎来了一波小更新，之前我们判断某个对象是否为某个类型或是某个类型的子类时，会用到`instanceof`关键字：

```java
public static void main(String[] args) {
    test(new Student());
}

//实现如果是学生就执行study方法
private static void test(Person person) {
    if(person instanceof Student) {   //首先判断是否为学生类型
        Student student = (Student) person;  //如果是直接进行强制类型转换
        student.study();   //执行学习
    }
}

static class Person { }
static class Student extends Person {
    void study() {
        System.out.println("我要打瓦");
    }
}
```

在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本`instanceof`加强之后，我们就不需要了，我们可以直接将student替换为模式变量：

```java
private static void test(Person person) {
    if(person instanceof Student student) {  //直接在instanceof后写变量名称，作为判断成功之后转换的此类型变量名称
        student.study();
    }
}
```

在使用`instanceof`判断类型成立后，会自动强制转换类型为指定类型，我们只需要指定强制转换之后的变量名称，简化了我们手动转换的步骤。注意此功能在Java 16中才实装，到Java 17才能不转换类型直接使用。



### (Java 8) 接口默认和静态方法

从Java8开始，接口中可以存在方法的默认实现：

```java
public interface Study {
    void study();

    default void test() {   //使用default关键字为接口中的方法添加默认实现
        System.out.println("我是默认实现");
    }
}
```

如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。

在之前接口中不允许存在任何实现的方法和和变量，从Java8开始，这些限制同样也放宽了，虽然还是不支持直接像抽象类那样写成员变量，但是静态变量和静态方法是可以写了：

```java
public interface Study {
    public static final int a = 10;   //接口中定义的静态变量可以是public static final的
  
  	public static void test(){    //接口中定义的静态方法只能是public的
        System.out.println("我是静态方法");
    }
    
    void study();
}
```

跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：

```java
public static void main(String[] args) {
    System.out.println(Study.a);
    Study.test();
}
```

有了这些特性之后，接口似乎变得也不是那么完全纯粹的抽象了。

### (Java 9) 接口中的private方法

Java8为接口提供的默认方法和静态方法虽然已经很方便，但是有些时候我们可能希望接口中有一些不愿意暴露出去的私有实现，比如：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();   //调用内部私有操作
    }
    
    default void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

但是由于接口中只能存在`public`的方法，这种需要内部封装的操作就无法实现，从Java9开始，接口中允许存在`private`访问权限的方法，此方法仅用于被默认方法使用：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private void inner() {   //Java 9开始支持使用private声明了，仅供接口内部使用
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

同样的，包括静态方法在内，也可以使用`private`访问权限进行声明：

```java
interface Study {
    static void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private static void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

在外面使用接口对应的对象时，跟类一样无法访问到私有成员。



### (Java 11) 字符串增强

官方在Java11对String类进行了一波加强，主要增加了很多对于字符的判定和特殊处理操作，我们来看看。

首先是用于去除字符串前后空格`strip`方法，他会自动去除字符串的前后空格：

```java
String string = "   Hello World   ";
System.out.println(string.strip());   //Hello World
```

可以看到，通过`strip()`直接去除字符串前后空格，不过仅仅是前后，不会去除其中间的空格。注意，当传入的字符串只有空格时，会返回一个空字符串。

当然，我们也可以使用`stripLeading`和`stripTrailing`来只对前面的空格或是后面的空格进行删除：

```java
String string = "   Hello World   ";
System.out.println(string.stripLeading());   //Hello World   
System.out.println(string.stripTrailing());   //   Hello World
```

这些操作跟之前一样，因为字符串本身是不可变的，所以返回的是一个新的字符串对象，而非对其本身进行修改。

除此之外，还有判断字符串是否为纯空格组成的：

```java
String string = "   ";
System.out.println(string.isBlank());  //判断是否只有空格（空串也算）
```

还有直接让字符串重复排列的操作：

```java
String string = "ABC";
System.out.println(string.repeat(5));   //让字符串内容重复5次
```

![image-20250708215325206](https://s2.loli.net/2025/07/08/DNvacpzWjh49EnJ.png)

### (Java 15) 文本块

如果你学习过Python，一定知道三引号：

```python
#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串
multi_line =  """
                nice to meet you!
                  nice to meet you!
                      nice to meet you!
                """
print multi_line
```

没错，Java 13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了，官方为其起的名字叫文本块，此功能在Java 15中实装。我们可以来测试一下：

```java
String string = """
        "dad"
        """;
System.out.println(string);  //"dad"
```

可以看到，Java中也可以使用这样的三引号来表示字符串了，并且可以随意在里面使用特殊字符，包括双引号等，不需要任何转义字符就能使用。当然，这个功能只是一个语法糖，最后编译出来的class文件还是会变成普通字符串，只是自动帮我们加了转义字符：

```java
String string = "\"dad\"\n";
System.out.println(string);
```

仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？



### (Java 21/22/25) switch模式匹配

在前面我们介绍了switch表达式，相比传统的switch语法，它可以非常方便地实现分支判断和结果返回：

```java
public static Integer test(String str) {
    return switch (str) {  //直接使用switch表达式的结果作为返回值
        case "A" -> 1;
        case "B" -> 2;
        default -> 0;
    };
}
```

 在Java 14中对switch进行了进一步增强，引入了模式匹配，可以直接判断目标类型，此功能最终在Java 21实装。原来我们如果要实现类型判断的分支语句，需要像这样编写：

```java
if(obj instanceof String) {
    System.out.println("String");
} else if(obj instanceof Integer){
    System.out.println("Integer");
} else {
    System.out.println("Other");
}
```

现在switc支持模式匹配后，我们可以像这样编写：

```java
public static void test(Object obj) {
    String type = switch (obj) {
        case String s -> "String";   //直接在case后写上类型和变量名称即可进行类型匹配
        case Integer i -> "Integer";
        case null -> "Null";   //甚至还可以直接判断null
        default -> "Other";
    };
    System.out.println(type);
}
```

通过这些改进，switch 语句在 Java 中的应用变得更加广泛和灵活。不过我们注意到，模式匹配中的类型后面必须跟一个变量名字，哪怕我根本就不用它，这似乎有点鸡肋，能否有一种办法省略掉呢？在Java 22之后，我们可以使用`_`下划线来直接取代，表示这是一个后续不会使用的未命名的变量：

```java
String type = switch (obj) {
    case String _ -> "String";   //直接使用_表示未命名变量
    case Integer _ -> "Integer";
    case null -> "Null";
    default -> "Other";
};
```

不止如此，我们还可以在模式后添加`when`子句进行额外条件检查，这种操作称为"守卫条件"：

```java
public static Integer test(String str) {
    return switch (str) {
        case String s when s.length() > 2 -> 1;  //使用when关键字
        case String s when s.isEmpty() -> 2;
        default -> 0;  //注意使用守卫条件后其他情况会变得不可预估，必须使用default对其他情况做处理
    };
}
```

只需在case语句后附加`when`关键字即可，`when`后面需要填写判断条件，和`if`一样，必须为一个返回值为`boolean`的表达式，也可以使用与或非操作：

```java
public static Integer test(String str) {
    return switch (str) {
        case String s when s.length() > 2 && s.contains("A") -> 1;
        case String _ -> 2;
    };
}
```

因此，我们做梦都想要的`switch`区间判断，在Java 21版本终于可以实现了（虽然隔壁Kotlin几年前就能用了）：

```java
return switch (score) {
    case Integer c when c >= 90 -> "优秀";   //注意switch是从上往下匹配，大于90要放前面优先匹配
    case Integer c when c >= 80 -> "良好";   //走到这里一定小于90，再判断是否大于80
    case Integer c when c >= 60 -> "及格";
    default -> "滚蛋";
};
```

**注意：** 可能很多小伙伴说为什么这里不直接用`int`基本类型呢？实际上针对于基本类型的模式匹配和守卫条件，在Java 24才作为预览特性支持，到Java 25之后才可以正式使用。

此外，针对于此前提到的记录类型，在`switch`语句中支持直接解构使用：

```java
record Point(int x, int y) {}

public static Integer test(Object object) {
    return switch (object) {
        case Point(int x, int y) -> x + y;  //直接解构其参数使用
        case String _ -> 10;
        default -> 5;
    };
}
```

这里针对于记录类型，类似重新写了一次类型声明，编写完整的类名加参数`Point(int x, int y)`表示当`object`如果是记录类型，则进入此分支且解构其内部成员变量，这里写的`x`和`y`作为结构出来的变量可以直接在后续使用。同样的，解构的变量如果后续不使用也可以直接使用下划线代替。

```java
return switch (object) {
    case Point(int _, int y) -> y;
    case String _ -> 10;
    default -> 5;
};
```

你以为这样就完了吗，`switch`还支持对记录类内部成员的类型嵌套匹配：

```java
record Container(Object data) {}  //这里data是Object类型的

public static Integer test(Container object) {
    return switch (object) {
        case Container(String str) -> str.length();  //其内部类型如果是String
        case Container(Integer i) -> i;  //其内部类型如果是Integer
        default -> 0;
    };
}
```

