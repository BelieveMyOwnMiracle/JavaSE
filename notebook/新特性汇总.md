# Jdk8之后版本的新特性汇总

### (Java 10) 局部变量类型推断

Java 10 引入了 `var` 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。

在Java10之后，我们可以使用`var`关键字来根据后面的结果自动识别类型：

```java
var a = 10;
```

此时，无论我们修改后面的变量值为什么类型的值，都可以自动进行推断：



### (Java 14) Switch表达式

在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在我们要给不同分数的学生打等级（学生满分10分）我们之前学习的传统`switch`语句像这样写：

```java
int score = 9;
char grade;
switch (score) {
    case 10:
    case 9:
        grade = 'A';
        break;
    case 8:
        grade = 'B';
        break;
    case 7:
    case 6:
        grade = 'C';
        break;
    default:
        grade = 'D';
}
System.out.println("学生等级为: " + grade);
```

这是在是太累了，每一种情况都要单独编写`case`和`break`语句，从现在开始，我们可以使用新的`switch`语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：

```java
int score = 9;
//直接让grade接受switch的结果
char grade = switch (score) {
    case 10, 9 -> 'A';   //case后面直接使用->来指定返回结果
    case 8 -> 'B';
    case 6, 7 -> 'C';  //当存在多个匹配条件时，使用逗号分隔
    default -> 'D';
};  //别忘了这种写法相当于赋值，最后需要加分号
System.out.println("学生等级为: " + grade);
```

是不是看起来简单多了？其中`grade`得到的就是每一个`case`语句`->`符号后的结果，不需要任何`break`操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：

```java
var res = switch (obj) {   //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收
    case [匹配值, ...] -> "优秀";   //case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -> 来返回如果匹配此case语句的结果
    case ...   //根据不同的分支，可以存在多个case
    default -> "不及格";   //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的
};
```

不过，有些时候可能我们并不能直接指定返回的结果，比如存在前置操作的情况下，我们可以像这样编写：

```java
char grade = switch (score) {
    case 9 -> 'A';
    case 8 -> 'B';
    case 6, 7 -> {
        System.out.println("我是额外操作");   //存在前置操作，无法直接指定结果
        yield 'C';   //在最后使用yield关键字来指定结果
    }
    default -> 'D';
};
```

我们可以使用`yield`关键字来指定延迟返回的结果，同样的，不需要任何`break`操作，分支会自动结束（注意`yield`执行之后，后续不能再有任何代码了，因为已经结束了）

这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。但是注意，箭头语法和传统语法在Java 21之前是不允许混用的，Java 21之后可以相互混用。



### (Java 9) 交互式编程

如果各位小伙伴学习过其他语言，比如Python、JavaScript这类解释型语言，应该能够体验到命令行交互编程的快捷。而Java9同样推出了相似的功能，让我们能够在命令行中直接编写和运行Java代码，我们可以使用`jshell`命令打开交互式编程工具：

当不需要使用时，输入`/exit`指令即可退出：

![image-20250707202517718](https://s2.loli.net/2025/07/07/aWF92KYwqhPDgcz.png)



### (Java 16) 类型判断模式匹配

在Java 14，`instanceof`迎来了一波小更新，之前我们判断某个对象是否为某个类型或是某个类型的子类时，会用到`instanceof`关键字：

```java
public static void main(String[] args) {
    test(new Student());
}

//实现如果是学生就执行study方法
private static void test(Person person) {
    if(person instanceof Student) {   //首先判断是否为学生类型
        Student student = (Student) person;  //如果是直接进行强制类型转换
        student.study();   //执行学习
    }
}

static class Person { }
static class Student extends Person {
    void study() {
        System.out.println("我要打瓦");
    }
}
```

在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本`instanceof`加强之后，我们就不需要了，我们可以直接将student替换为模式变量：

```java
private static void test(Person person) {
    if(person instanceof Student student) {  //直接在instanceof后写变量名称，作为判断成功之后转换的此类型变量名称
        student.study();
    }
}
```

在使用`instanceof`判断类型成立后，会自动强制转换类型为指定类型，我们只需要指定强制转换之后的变量名称，简化了我们手动转换的步骤。注意此功能在Java 16中才实装，到Java 17才能不转换类型直接使用。



### (Java 8) 接口默认和静态方法

从Java8开始，接口中可以存在方法的默认实现：

```java
public interface Study {
    void study();

    default void test() {   //使用default关键字为接口中的方法添加默认实现
        System.out.println("我是默认实现");
    }
}
```

如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。

在之前接口中不允许存在任何实现的方法和和变量，从Java8开始，这些限制同样也放宽了，虽然还是不支持直接像抽象类那样写成员变量，但是静态变量和静态方法是可以写了：

```java
public interface Study {
    public static final int a = 10;   //接口中定义的静态变量可以是public static final的
  
  	public static void test(){    //接口中定义的静态方法只能是public的
        System.out.println("我是静态方法");
    }
    
    void study();
}
```

跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：

```java
public static void main(String[] args) {
    System.out.println(Study.a);
    Study.test();
}
```

有了这些特性之后，接口似乎变得也不是那么完全纯粹的抽象了。

### (Java 9) 接口中的private方法

Java8为接口提供的默认方法和静态方法虽然已经很方便，但是有些时候我们可能希望接口中有一些不愿意暴露出去的私有实现，比如：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();   //调用内部私有操作
    }
    
    default void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

但是由于接口中只能存在`public`的方法，这种需要内部封装的操作就无法实现，从Java9开始，接口中允许存在`private`访问权限的方法，此方法仅用于被默认方法使用：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private void inner() {   //Java 9开始支持使用private声明了，仅供接口内部使用
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

同样的，包括静态方法在内，也可以使用`private`访问权限进行声明：

```java
interface Study {
    static void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private static void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

在外面使用接口对应的对象时，跟类一样无法访问到私有成员。



### (Java 11) 字符串增强

官方在Java11对String类进行了一波加强，主要增加了很多对于字符的判定和特殊处理操作，我们来看看。

首先是用于去除字符串前后空格`strip`方法，他会自动去除字符串的前后空格：

```java
String string = "   Hello World   ";
System.out.println(string.strip());   //Hello World
```

可以看到，通过`strip()`直接去除字符串前后空格，不过仅仅是前后，不会去除其中间的空格。注意，当传入的字符串只有空格时，会返回一个空字符串。

当然，我们也可以使用`stripLeading`和`stripTrailing`来只对前面的空格或是后面的空格进行删除：

```java
String string = "   Hello World   ";
System.out.println(string.stripLeading());   //Hello World   
System.out.println(string.stripTrailing());   //   Hello World
```

这些操作跟之前一样，因为字符串本身是不可变的，所以返回的是一个新的字符串对象，而非对其本身进行修改。

除此之外，还有判断字符串是否为纯空格组成的：

```java
String string = "   ";
System.out.println(string.isBlank());  //判断是否只有空格（空串也算）
```

还有直接让字符串重复排列的操作：

```java
String string = "ABC";
System.out.println(string.repeat(5));   //让字符串内容重复5次
```

![image-20250708215325206](https://s2.loli.net/2025/07/08/DNvacpzWjh49EnJ.png)

### (Java 15) 文本块

如果你学习过Python，一定知道三引号：

```python
#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串
multi_line =  """
                nice to meet you!
                  nice to meet you!
                      nice to meet you!
                """
print multi_line
```

没错，Java 13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了，官方为其起的名字叫文本块，此功能在Java 15中实装。我们可以来测试一下：

```java
String string = """
        "dad"
        """;
System.out.println(string);  //"dad"
```

可以看到，Java中也可以使用这样的三引号来表示字符串了，并且可以随意在里面使用特殊字符，包括双引号等，不需要任何转义字符就能使用。当然，这个功能只是一个语法糖，最后编译出来的class文件还是会变成普通字符串，只是自动帮我们加了转义字符：

```java
String string = "\"dad\"\n";
System.out.println(string);
```

仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？



### (Java 21/22/25) switch模式匹配

在前面我们介绍了switch表达式，相比传统的switch语法，它可以非常方便地实现分支判断和结果返回：

```java
public static Integer test(String str) {
    return switch (str) {  //直接使用switch表达式的结果作为返回值
        case "A" -> 1;
        case "B" -> 2;
        default -> 0;
    };
}
```

 在Java 14中对switch进行了进一步增强，引入了模式匹配，可以直接判断目标类型，此功能最终在Java 21实装。原来我们如果要实现类型判断的分支语句，需要像这样编写：

```java
if(obj instanceof String) {
    System.out.println("String");
} else if(obj instanceof Integer){
    System.out.println("Integer");
} else {
    System.out.println("Other");
}
```

现在switc支持模式匹配后，我们可以像这样编写：

```java
public static void test(Object obj) {
    String type = switch (obj) {
        case String s -> "String";   //直接在case后写上类型和变量名称即可进行类型匹配
        case Integer i -> "Integer";
        case null -> "Null";   //甚至还可以直接判断null
        default -> "Other";
    };
    System.out.println(type);
}
```

通过这些改进，switch 语句在 Java 中的应用变得更加广泛和灵活。不过我们注意到，模式匹配中的类型后面必须跟一个变量名字，哪怕我根本就不用它，这似乎有点鸡肋，能否有一种办法省略掉呢？在Java 22之后，我们可以使用`_`下划线来直接取代，表示这是一个后续不会使用的未命名的变量：

```java
String type = switch (obj) {
    case String _ -> "String";   //直接使用_表示未命名变量
    case Integer _ -> "Integer";
    case null -> "Null";
    default -> "Other";
};
```

不止如此，我们还可以在模式后添加`when`子句进行额外条件检查，这种操作称为"守卫条件"：

```java
public static Integer test(String str) {
    return switch (str) {
        case String s when s.length() > 2 -> 1;  //使用when关键字
        case String s when s.isEmpty() -> 2;
        default -> 0;  //注意使用守卫条件后其他情况会变得不可预估，必须使用default对其他情况做处理
    };
}
```

只需在case语句后附加`when`关键字即可，`when`后面需要填写判断条件，和`if`一样，必须为一个返回值为`boolean`的表达式，也可以使用与或非操作：

```java
public static Integer test(String str) {
    return switch (str) {
        case String s when s.length() > 2 && s.contains("A") -> 1;
        case String _ -> 2;
    };
}
```

因此，我们做梦都想要的`switch`区间判断，在Java 21版本终于可以实现了（虽然隔壁Kotlin几年前就能用了）：

```java
return switch (score) {
    case Integer c when c >= 90 -> "优秀";   //注意switch是从上往下匹配，大于90要放前面优先匹配
    case Integer c when c >= 80 -> "良好";   //走到这里一定小于90，再判断是否大于80
    case Integer c when c >= 60 -> "及格";
    default -> "滚蛋";
};
```

**注意：** 可能很多小伙伴说为什么这里不直接用`int`基本类型呢？实际上针对于基本类型的模式匹配和守卫条件，在Java 24才作为预览特性支持，到Java 25之后才可以正式使用。

此外，针对于此前提到的记录类型，在`switch`语句中支持直接解构使用：

```java
record Point(int x, int y) {}

public static Integer test(Object object) {
    return switch (object) {
        case Point(int x, int y) -> x + y;  //直接解构其参数使用
        case String _ -> 10;
        default -> 5;
    };
}
```

这里针对于记录类型，类似重新写了一次类型声明，编写完整的类名加参数`Point(int x, int y)`表示当`object`如果是记录类型，则进入此分支且解构其内部成员变量，这里写的`x`和`y`作为结构出来的变量可以直接在后续使用。同样的，解构的变量如果后续不使用也可以直接使用下划线代替。

```java
return switch (object) {
    case Point(int _, int y) -> y;
    case String _ -> 10;
    default -> 5;
};
```

你以为这样就完了吗，`switch`还支持对记录类内部成员的类型嵌套匹配：

```java
record Container(Object data) {}  //这里data是Object类型的

public static Integer test(Container object) {
    return switch (object) {
        case Container(String str) -> str.length();  //其内部类型如果是String
        case Container(Integer i) -> i;  //其内部类型如果是Integer
        default -> 0;
    };
}
```



### (Java 8) 新的日期类

==Java 8 引入了一套全新的日期和时间 API==，主要包括以下几个核心类，它们都位于 `java.time` 包中，旨在解决旧版 `java.util.Date` 和 `java.util.Calendar` 设计上的不足。

Java 8为我们提供了几种全新的日期类型：

* **LocalDate：** 表示没有时间部分的日期（年、月、日）例如：2024-04-27
* **LocalTime：** 表示没有日期部分的时间（时、分、秒、纳秒）例如：14:30:00
* **LocalDateTime：** 表示日期和时间的组合（没有时区信息）例如：2024-04-27T14:30:00
* **ZonedDateTime：** 表示带有时区的日期和时间，例如：2024-04-27T14:30:00+08:00[Asia/Shanghai]

我们首先来体验下普通的LocalDate类，它只代表一个日期，不包含具体时分秒等信息：

```java
LocalDate date = LocalDate.now();  //需要使用其内部的静态方法创建对象
LocalDate date1 = LocalDate.of(2025, 10, 11);  //按年月日创建所见即所得
LocalDate date2 = LocalDate.of(2025, Month.AUGUST, 18);   //同上，按年月日创建
LocalDate date3 = LocalDate.ofYearDay(2025, 240);   //直接取2025年的第240天
System.out.println(date);
```

使用`now()`方法可以立即创建一个代表当前时间的`LocalDate`对象，其中包含了很多关于日期的工具方法：

```java
System.out.println("月份: " + date.getMonth());
System.out.println("月份数字: " + date.getMonthValue());
System.out.println("年份: " + date.getYear());
System.out.println("今年的第几天: " + date.getDayOfYear());
System.out.println("这个月的第几天: " + date.getDayOfMonth());
System.out.println("这周的第几天: " + date.getDayOfWeek());
```

其中，月份返回的是一个`Month`对象，其中包含大量对于月份的处理方法。除此之外，它还内置了大量计算操作，比如我们希望这个日期向后加7天，可以直接调用`plus`方法：

![image-20250708162144958](https://s2.loli.net/2025/07/08/5msecNL2D3SlMqO.png)

当然向后减去天数的操作也有：

![image-20250708162231000](https://s2.loli.net/2025/07/08/FupaO5kYCItrUJM.png)

不过需要注意，`LocalDate`本身的日期是不可变的，我们进行加减操作之后得到的结果是对于原对象的拷贝重新生成的对象，包括我们如果想要单独修改年月日，也只能使用`with`方法来创建副本：

![image-20250708162431195](https://s2.loli.net/2025/07/08/tmpcT6ZDoQXaRbB.png)

我们接着来看用于表示时间的`LocalTime`对象，用法也非常简单，支持通过静态方法或是直接使用内置的静态变量：

```java
LocalTime time = LocalTime.now();   //现在的时间
LocalTime time1 = LocalTime.of(12, 30);   //指定时分
LocalTime time2 = LocalTime.of(12, 30, 0);   //指定时分秒
LocalTime time3 = LocalTime.of(12, 30, 0, 0);  //指定时分秒以及纳秒(注意不是毫秒)
LocalTime time4 = LocalTime.MAX;   //LocalTime最大支持时间，也是即将到达下一天的最大时间23:59:59.999
LocalTime time5 = LocalTime.MIN;   //LocalTime最小支持时间，也是一天开始的时间0:00:00.000
LocalTime time6 = LocalTime.MIDNIGHT;   //同上，午夜，也就是一天开始的时间0:00:00.000
LocalTime time7 = LocalTime.NOON;    //中午，12:00:00.000
```

它只能代表某一个时刻，不包含日期：

```java
LocalTime time = LocalTime.now();
System.out.println(time);
```

![image-20250708161914665](https://s2.loli.net/2025/07/08/fYGUMJhXO4IjTrV.png)

和`LocalDate`一样，它也内置了很多工具方法，方便我们使用：

```java
LocalTime time = LocalTime.now();
System.out.println("小时: " + time.getHour());
System.out.println("分钟: " + time.getMinute());
System.out.println("秒: " + time.getSecond());
```

它同样也包括`LocalDate`中的加减操作、单独修改时分秒操作，同样会生成副本对象，这里就不详细介绍了。

我们接着来看`LocalDate`和`LocalTime`的结合体，`LocalDateTime`包含了完整的时间信息，和之前使用的`Date`比较相似，想要创建也非常简单：

```java
LocalDateTime time = LocalDateTime.now();
LocalDateTime time2 = LocalDateTime.of(LocalDate.now(), LocalTime.now()); //融合两个对象
LocalDateTime time3 = LocalDateTime.of(2025, 10, 1, 23, 18, 0);  //年月日时分秒
```

`LocalDateTime`包含了`LocalDate`和`LocalTime`内的所有方法，使用起来更加全面。

同时，`LocalDate`和`LocalTime`也内置了一键补全确实的日期信息的方法，能够直接转换为`LocalDateTime`对象：

```java
LocalDate date = LocalDate.now();
System.out.println(date.atTime(LocalTime.now()));  //补齐时分秒
System.out.println(date.atTime(12, 0, 0)); //补齐时分秒

LocalTime time = LocalTime.now();
System.out.println(time.atDate(LocalDate.of(2025, 1, 1)));  //补齐年月日

LocalDateTime time = LocalDateTime.now();
time.toLocalTime();   //能转过来，那拆回去肯定也是没问题的
time.toLocalDate();
```

对于时间的格式化，Java 8也提供了一个全新的`DateTimeFormatter`类：

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
```

用法和之前的`SimpleDateFormat`类似，如果我们需要将字符串日期进行转换，可以像这样做：

```java
//首先创建日期格式化工具
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
//使用parse指定格式进行转换
LocalDateTime now = LocalDateTime.parse("2025-01-01 01:18:22", formatter);
System.out.println(now);
```

也可以直接通过`SimpleDateFormat`进行转换，会返回一个`TemporalAccessor`类型的对象，它是我们之前认识的几种日期对象的公共父接口，但是注意，它的具体实现类并不是我们想要的类型，而是其他的实现类，不过日期类同样有对应的`from`转换方法：

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
LocalDateTime time = LocalDateTime.from(formatter.parse("2025-01-01 01:18:22"));
//使用from转换返回的TemporalAccessor为对应日期对象
```

如果要把日期转换为格式化的字符串，也是和之前一样的，直接使用`format`方法即可：

```java
DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
System.out.println(formatter.format(LocalDateTime.now()));
```

我们接着来看携带偏移值的日期类，它相比`LocalDateTime`多了一个时间偏移，创建方式还是一样的：

```java
OffsetDateTime time = OffsetDateTime.now();
OffsetDateTime time = LocalDateTime.now().atOffset(ZoneOffset.UTC); //也可以直接用LocalDateTime补全信息创建，需要携带时间偏移
System.out.println(time);
```

![image-20250708182739301](https://s2.loli.net/2025/07/08/v7YAtjEzN8gJaID.png)

这里的+08:00实际上就是UTC时间的偏移，中国正好是东八区也就是UTC+8，所以默认得到的时间就是+8小时。

可能细心的小伙伴在之前已经发现，不仅仅是`OffsetDateTime`，之前的几个类型都可以在创建时指定时区：

```java
LocalDate date = LocalDate.now(ZoneId.of("UTC+0"));  //直接指定UTC时区
LocalDateTime time = LocalDateTime.now(ZoneId.of("UTC+0"));
OffsetDateTime offset = OffsetDateTime.now(ZoneId.of("UTC+0"));
```

虽然之前几种时间类型允许传入时区，生成出来的时间也确实是对应时区的时间，但是其中不会保存有关时区的设置，得到的只是对应时区的时间，而`OffsetDateTime`内部会保存时区，我们可以通过`getOffset()`获取：

```java
OffsetDateTime offset = OffsetDateTime.now(ZoneId.of("UTC+5"));
//返回一个ZoneOffset对象，包含时间偏移量信息
System.out.println(offset.getOffset());  //当时区为UTC标准时区打印Z，其他时间打印+05:00这种
```

注意这个时间偏移量可以精确到秒，并非只能严格按小时：

```java
OffsetDateTime offset = OffsetDateTime.now(ZoneId.of("UTC+05:00:02"));
System.out.println(offset);  //2025-07-08T15:52:39.926356+05:00:02
```

我们接着来看携带时区信息的日期对象`ZonedDateTime`，他相比`OffsetDateTime`信息则更全面，不仅携带偏移值，还携带了时区信息，注意偏移值和时区不是一个概念，偏移值只是表示时间需要向前或是向后偏移多少，而时区信息则包含更加完整的时区信息，比如时区ID等，创建方式也很简单：

```java
ZonedDateTime time = ZonedDateTime.now();
ZonedDateTime time = LocalDateTime.now().atZone(ZoneOffset.UTC);  //LocalDateTime补全时区信息
System.out.println(time);
```

![image-20250708165726855](https://s2.loli.net/2025/07/08/kdRn4rBjPoHbtAi.png)

默认的时区为系统设定的时区，我们也可以手动指定其他地区。我们可以打印看下当前时区信息：

```java
ZonedDateTime time = ZonedDateTime.now();
System.out.println(time.getZone());
```

![image-20250708185807803](https://s2.loli.net/2025/07/08/nGu7HgQNSIJKMPU.png)

这里的时区信息其实就是时区对应的城市。

接着需要给大家介绍一个==非常特殊的时间类型`Instant`，它用于表示时间线上的一个点，通常用来表示时间戳==（即自1970年1月1日格林威治标准时间（UTC）以来的秒数或毫秒数）可能大家会认为它跟之前的日期一样也是表示时间的，但是从定义来说，它更适合表示某一个时间点的时间戳。构造起来很简单：

```java
Instant instant = Instant.now();
Instant.ofEpochSecond(1);  //也可以通过时间点创建，这里是1970-01-01 0:00:01
Instant.ofEpochSecond(0, 1);  //可以精确到纳秒
System.out.println(instant);
```

从打印结果可以看到，其输出默认为格林威治时间，而不是根据当前系统时区展示，所以确实很像是只表示时间戳，而非给我们当做时间对象使用的，并且它的内部不存在任何获取日期时间信息的方法，像是一个砍掉所有功能只用于保存时间的`LocalDateTime`对象。

对于我们之前使用的`Date`对象，在Java8之后同样也可以快速转换为`Instant`对象：

```java
Date date = new Date();
Instant instant = date.toInstant();
```

最后是用于表示时间持续和频率的两个工具类，他们都用作表示时间段，也可以被用来计算时间的差：

```java
Duration duration = Duration.ofSeconds(1);   //表示相差时间1秒
Duration.between(LocalTime.now(), LocalTime.now().plusDays(1));  //通过between来计算两个时间的差值
Period period = Period.ofDays(1);   //表示相差时间1天
```

其中，Duration用于计算时间更精确的差值，精确到秒和纳秒，而Period用于粗略计算差值，精确到天。
