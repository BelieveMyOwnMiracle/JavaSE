# Jdk8之后版本的新特性汇总

### (Java 10) 局部变量类型推断

Java 10 引入了 `var` 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。

在Java10之后，我们可以使用`var`关键字来根据后面的结果自动识别类型：

```java
var a = 10;
```

此时，无论我们修改后面的变量值为什么类型的值，都可以自动进行推断：



### (Java 14) Switch表达式

在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在我们要给不同分数的学生打等级（学生满分10分）我们之前学习的传统`switch`语句像这样写：

```java
int score = 9;
char grade;
switch (score) {
    case 10:
    case 9:
        grade = 'A';
        break;
    case 8:
        grade = 'B';
        break;
    case 7:
    case 6:
        grade = 'C';
        break;
    default:
        grade = 'D';
}
System.out.println("学生等级为: " + grade);
```

这是在是太累了，每一种情况都要单独编写`case`和`break`语句，从现在开始，我们可以使用新的`switch`语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：

```java
int score = 9;
//直接让grade接受switch的结果
char grade = switch (score) {
    case 10, 9 -> 'A';   //case后面直接使用->来指定返回结果
    case 8 -> 'B';
    case 6, 7 -> 'C';  //当存在多个匹配条件时，使用逗号分隔
    default -> 'D';
};  //别忘了这种写法相当于赋值，最后需要加分号
System.out.println("学生等级为: " + grade);
```

是不是看起来简单多了？其中`grade`得到的就是每一个`case`语句`->`符号后的结果，不需要任何`break`操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：

```java
var res = switch (obj) {   //这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收
    case [匹配值, ...] -> "优秀";   //case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -> 来返回如果匹配此case语句的结果
    case ...   //根据不同的分支，可以存在多个case
    default -> "不及格";   //注意，表达式要求必须涵盖所有的可能，所以是需要添加default的
};
```

不过，有些时候可能我们并不能直接指定返回的结果，比如存在前置操作的情况下，我们可以像这样编写：

```java
char grade = switch (score) {
    case 9 -> 'A';
    case 8 -> 'B';
    case 6, 7 -> {
        System.out.println("我是额外操作");   //存在前置操作，无法直接指定结果
        yield 'C';   //在最后使用yield关键字来指定结果
    }
    default -> 'D';
};
```

我们可以使用`yield`关键字来指定延迟返回的结果，同样的，不需要任何`break`操作，分支会自动结束（注意`yield`执行之后，后续不能再有任何代码了，因为已经结束了）

这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。但是注意，箭头语法和传统语法在Java 21之前是不允许混用的，Java 21之后可以相互混用。



### (Java 9) 交互式编程

如果各位小伙伴学习过其他语言，比如Python、JavaScript这类解释型语言，应该能够体验到命令行交互编程的快捷。而Java9同样推出了相似的功能，让我们能够在命令行中直接编写和运行Java代码，我们可以使用`jshell`命令打开交互式编程工具：

当不需要使用时，输入`/exit`指令即可退出：

![image-20250707202517718](https://s2.loli.net/2025/07/07/aWF92KYwqhPDgcz.png)



### (Java 16) 类型判断模式匹配

在Java 14，`instanceof`迎来了一波小更新，之前我们判断某个对象是否为某个类型或是某个类型的子类时，会用到`instanceof`关键字：

```java
public static void main(String[] args) {
    test(new Student());
}

//实现如果是学生就执行study方法
private static void test(Person person) {
    if(person instanceof Student) {   //首先判断是否为学生类型
        Student student = (Student) person;  //如果是直接进行强制类型转换
        student.study();   //执行学习
    }
}

static class Person { }
static class Student extends Person {
    void study() {
        System.out.println("我要打瓦");
    }
}
```

在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本`instanceof`加强之后，我们就不需要了，我们可以直接将student替换为模式变量：

```java
private static void test(Person person) {
    if(person instanceof Student student) {  //直接在instanceof后写变量名称，作为判断成功之后转换的此类型变量名称
        student.study();
    }
}
```

在使用`instanceof`判断类型成立后，会自动强制转换类型为指定类型，我们只需要指定强制转换之后的变量名称，简化了我们手动转换的步骤。注意此功能在Java 16中才实装，到Java 17才能不转换类型直接使用。



### (Java 8) 接口默认和静态方法

从Java8开始，接口中可以存在方法的默认实现：

```java
public interface Study {
    void study();

    default void test() {   //使用default关键字为接口中的方法添加默认实现
        System.out.println("我是默认实现");
    }
}
```

如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。

在之前接口中不允许存在任何实现的方法和和变量，从Java8开始，这些限制同样也放宽了，虽然还是不支持直接像抽象类那样写成员变量，但是静态变量和静态方法是可以写了：

```java
public interface Study {
    public static final int a = 10;   //接口中定义的静态变量可以是public static final的
  
  	public static void test(){    //接口中定义的静态方法只能是public的
        System.out.println("我是静态方法");
    }
    
    void study();
}
```

跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：

```java
public static void main(String[] args) {
    System.out.println(Study.a);
    Study.test();
}
```

有了这些特性之后，接口似乎变得也不是那么完全纯粹的抽象了。

### (Java 9) 接口中的private方法

Java8为接口提供的默认方法和静态方法虽然已经很方便，但是有些时候我们可能希望接口中有一些不愿意暴露出去的私有实现，比如：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();   //调用内部私有操作
    }
    
    default void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

但是由于接口中只能存在`public`的方法，这种需要内部封装的操作就无法实现，从Java9开始，接口中允许存在`private`访问权限的方法，此方法仅用于被默认方法使用：

```java
interface Study {
    default void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private void inner() {   //Java 9开始支持使用private声明了，仅供接口内部使用
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

同样的，包括静态方法在内，也可以使用`private`访问权限进行声明：

```java
interface Study {
    static void study() {
        System.out.println("我要狠狠学习");
        inner();
    }
    private static void inner() {
        System.out.println("我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的");
    }
}
```

在外面使用接口对应的对象时，跟类一样无法访问到私有成员。